<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ±äº¬ã®åœ°ä¸‹é‰„ 3Dè·¯ç·šå›³</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000011;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 50, 0.8);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            line-height: 0.7;
        }
        
        #controls {
            margin-top: 10px;
        }
        
        button {
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            border: none;
            color: white;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }
        
        select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            margin: 5px;
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 50, 0.8);
            padding: 10px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            min-width: 200px;
        }
        
        .line-legend {
            margin-top: 10px;
        }
        
        .line-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        
        .line-color {
            width: 20px;
            height: 3px;
            margin-right: 10px;
            border-radius: 2px;
        }

        /* 2Dé§…åãƒ©ãƒ™ãƒ«ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #station-labels-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’é€éã•ã›ã‚‹ */
            z-index: 99; /* UIã‚ˆã‚Šä¸‹ã€Three.jsã‚­ãƒ£ãƒ³ãƒã‚¹ã‚ˆã‚Šä¸Š */
        }

        .station-label {
            position: absolute;
            color: white;
            font-size: 14px; /* ãƒ†ã‚­ã‚¹ãƒˆã‚µã‚¤ã‚ºã‚’èª¿æ•´ */
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8); /* èª­ã¿ã‚„ã™ãã™ã‚‹ãŸã‚ã®å½± */
            background: rgba(0, 0, 0, 0.4); /* èƒŒæ™¯ã‚’è¿½åŠ ã—ã¦èª­ã¿ã‚„ã™ã */
            padding: 2px 5px;
            border-radius: 5px;
            transform: translate(-50%, -100%); /* ä¸­å¤®æƒãˆã¨é§…çƒä½“ã®ä¸Šéƒ¨ã«é…ç½® */
            white-space: nowrap; /* ãƒ†ã‚­ã‚¹ãƒˆãŒæŠ˜ã‚Šè¿”ã•ã‚Œãªã„ã‚ˆã†ã« */
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="ui">
            <h3>æ±äº¬ã®åœ°ä¸‹é‰„ 3Dè·¯ç·šå›³<br><p style="font-size: 15px;">by Salmon</p></h3>
            <button id="close-ui" style="position: absolute; top: 10px; right: 10px; background: none; border: none; color: white; font-size: 20px; cursor: pointer;">Ã—</button>
            <div id="controls">
                <button onclick="toggleAnimation()">â¯ï¸ å›è»¢åˆ‡æ›¿</button>
                <button onclick="toggleStationLabels()">ğŸš é§…åè¡¨ç¤ºåˆ‡æ›¿</button>
                <select onchange="focusLine(this.value)">
                    <option value="">è·¯ç·šã‚’é¸æŠ</option>
                    <option value="æ—¥æ¯”è°·ç·š">æ—¥æ¯”è°·ç·š</option>
                    <option value="éŠ€åº§ç·š">éŠ€åº§ç·š</option>
                    <option value="ä¸¸ãƒå†…ç·š">ä¸¸ãƒå†…ç·š</option>
                    <option value="æ±è¥¿ç·š">æ±è¥¿ç·š</option>
                    <option value="å—åŒ—ç·š">å—åŒ—ç·š</option>
                    <option value="æœ‰æ¥½ç”ºç·š">æœ‰æ¥½ç”ºç·š</option>
                    <option value="åƒä»£ç”°ç·š">åƒä»£ç”°ç·š</option>
                    <option value="åŠè”µé–€ç·š">åŠè”µé–€ç·š</option>
                    <option value="å‰¯éƒ½å¿ƒç·š">å‰¯éƒ½å¿ƒç·š</option>
                    <option value="æµ…è‰ç·š">æµ…è‰ç·š</option>
                    <option value="ä¸‰ç”°ç·š">ä¸‰ç”°ç·š</option>
                    <option value="æ–°å®¿ç·š">æ–°å®¿ç·š</option>
                    <option value="å¤§æ±Ÿæˆ¸ç·š">å¤§æ±Ÿæˆ¸ç·š</option>
                </select>
            </div>
            <p style="line-height: 1.7;"><a href="https://nlftp.mlit.go.jp/ksj/gml/datalist/KsjTmplt-N02-v2_3.html" style="color: white;">å›½äº¤çœãƒ‡ãƒ¼ã‚¿</a>ã€æ±äº¬ãƒ¡ãƒˆãƒ­ï¾ƒï¾ï½°ï¾€ï½ºï¾ï¾ƒï¾ï¾‚ã€<br><a href="https://creativecommons.org/licenses/by/4.0/deed.ja" style="color: white;">æ±äº¬éƒ½ã‚ªãƒ¼ãƒ—ãƒ³ãƒ‡ãƒ¼ã‚¿(CC BY 4.0)</a>ã‚’åŠ å·¥ã—ã¦ä½œæˆ</p>
        </div>
        
        <div id="info">
            <div id="station-info">ãƒã‚¦ã‚¹ã§é§…ã‚’ã‚¯ãƒªãƒƒã‚¯</div>
            <div class="line-legend">
                <div class="line-item"><div class="line-color" style="background: #B5B5AC;"></div><span>æ—¥æ¯”è°·ç·š</span></div>
                <div class="line-item"><div class="line-color" style="background: #FF9500;"></div><span>éŠ€åº§ç·š</span></div>
                <div class="line-item"><div class="line-color" style="background: #F62E36;"></div><span>ä¸¸ãƒå†…ç·š</span></div>
                <div class="line-item"><div class="line-color" style="background: #009BBF;"></div><span>æ±è¥¿ç·š</span></div>
                <div class="line-item"><div class="line-color" style="background: #00AC9A;"></div><span>å—åŒ—ç·š</span></div>
                <div class="line-item"><div class="line-color" style="background: #C1A470;"></div><span>æœ‰æ¥½ç”ºç·š</span></div>
                <div class="line-item"><div class="line-color" style="background: #00B5AD;"></div><span>åƒä»£ç”°ç·š</span></div>
                <div class="line-item"><div class="line-color" style="background: #8F76D6;"></div><span>åŠè”µé–€ç·š</span></div>
                <div class="line-item"><div class="line-color" style="background: #9C5F2A;"></div><span>å‰¯éƒ½å¿ƒç·š</span></div>
                <div class="line-item"><div class="line-color" style="background: #E85298;"></div><span>æµ…è‰ç·š</span></div>
                <div class="line-item"><div class="line-color" style="background: #0079C2;"></div><span>ä¸‰ç”°ç·š</span></div>
                <div class="line-item"><div class="line-color" style="background: #6CBB5A;"></div><span>æ–°å®¿ç·š</span></div>
                <div class="line-item"><div class="line-color" style="background: #B6007A;"></div><span>å¤§æ±Ÿæˆ¸ç·š</span></div>
            </div>
        </div>
        <div id="station-labels-container"></div> </div>

    <script>
        // Three.jsé–¢é€£ã®å¤‰æ•°
        let scene, camera, renderer, controls;
        let stations = []; // Three.jsã®é§…ãƒ¡ãƒƒã‚·ãƒ¥
        let lines = [];    // Three.jsã®è·¯ç·šãƒ¡ãƒƒã‚·ãƒ¥
        let stationLabels = []; // 2D HTMLé§…åãƒ©ãƒ™ãƒ«ã®è¦ç´ ã¨é–¢é€£ãƒ‡ãƒ¼ã‚¿ã‚’æ ¼ç´
        let isAnimating = false; // ã‚«ãƒ¡ãƒ©ã®è‡ªå‹•å›è»¢ãƒ•ãƒ©ã‚°
        let stationData = []; // èª­ã¿è¾¼ã‚“ã JSONãƒ‡ãƒ¼ã‚¿
        let consolidatedStations = []; // çµ±åˆã•ã‚ŒãŸé§…ãƒ‡ãƒ¼ã‚¿

        // è·¯ç·šã‚«ãƒ©ãƒ¼ãƒãƒƒãƒ—
        const lineColors = {
            '2å·ç·šæ—¥æ¯”è°·ç·š': 0xB5B5AC,
            '3å·ç·šéŠ€åº§ç·š': 0xFF9500,
            '4å·ç·šä¸¸ãƒå†…ç·š': 0xF62E36,
            '4å·ç·šä¸¸ãƒå†…ç·šåˆ†å²ç·š': 0xF62E36,
            '5å·ç·šæ±è¥¿ç·š': 0x009BBF,
            '7å·ç·šå—åŒ—ç·š': 0x00AC9A,
            '8å·ç·šæœ‰æ¥½ç”ºç·š': 0xC1A470,
            '9å·ç·šåƒä»£ç”°ç·š': 0x00BB85,
            '11å·ç·šåŠè”µé–€ç·š': 0x8F76D6,
            '13å·ç·šå‰¯éƒ½å¿ƒç·š': 0x9C5F2A,
            '1å·ç·šæµ…è‰ç·š': 0xE85298,
            '6å·ç·šä¸‰ç”°ç·š': 0x0079C2,
            '10å·ç·šæ–°å®¿ç·š': 0x6CBB5A,
            '12å·ç·šå¤§æ±Ÿæˆ¸ç·š': 0xB6007A
        };

        // è·¯ç·šã”ã¨ã®é§…é †åº (è·¯ç·šå›³ã®æç”»é †åºã«å½±éŸ¿)
        const lineOrders = {
            '2å·ç·šæ—¥æ¯”è°·ç·š': ['ä¸­ç›®é»’', 'æµæ¯”å¯¿', 'åºƒå°¾', 'å…­æœ¬æœ¨', 'ç¥è°·ç”º', 'è™ãƒé–€ãƒ’ãƒ«ã‚º', 'éœã‚±é–¢', 'æ—¥æ¯”è°·', 'éŠ€åº§', 'æ±éŠ€åº§', 'ç¯‰åœ°', 'å…«ä¸å €', 'èŒ…å ´ç”º', 'äººå½¢ç”º', 'å°ä¼é¦¬ç”º', 'ç§‹è‘‰åŸ', 'ä»²å¾¡å¾’ç”º', 'ä¸Šé‡', 'å…¥è°·', 'ä¸‰ãƒè¼ª', 'å—åƒä½', 'åŒ—åƒä½'],
            '3å·ç·šéŠ€åº§ç·š': ['æ¸‹è°·', 'è¡¨å‚é“', 'å¤–è‹‘å‰', 'é’å±±ä¸€ä¸ç›®', 'èµ¤å‚è¦‹é™„', 'æºœæ± å±±ç‹', 'è™ãƒé–€', 'æ–°æ©‹', 'éŠ€åº§', 'äº¬æ©‹', 'æ—¥æœ¬æ©‹', 'ä¸‰è¶Šå‰', 'ç¥ç”°', 'æœ«åºƒç”º', 'ä¸Šé‡åºƒå°è·¯', 'ä¸Šé‡', 'ç¨²è·ç”º', 'ç”°åŸç”º', 'æµ…è‰'],
            '4å·ç·šä¸¸ãƒå†…ç·š': ['è»çªª', 'å—é˜¿ä½ãƒ¶è°·', 'æ–°é«˜å††å¯º', 'æ±é«˜å††å¯º', 'æ–°ä¸­é‡', 'ä¸­é‡å‚ä¸Š', 'è¥¿æ–°å®¿', 'æ–°å®¿', 'æ–°å®¿ä¸‰ä¸ç›®', 'æ–°å®¿å¾¡è‹‘å‰', 'å››è°·ä¸‰ä¸ç›®', 'å››ãƒ„è°·', 'èµ¤å‚è¦‹é™„', 'å›½ä¼šè­°äº‹å ‚å‰', 'éœã‚±é–¢', 'éŠ€åº§', 'æ±äº¬', 'äº¬æ©‹', 'å¤§æ‰‹ç”º', 'æ·¡è·¯ç”º', 'å¾¡èŒ¶ãƒæ°´', 'æœ¬éƒ·ä¸‰ä¸ç›®', 'å¾Œæ¥½åœ’', 'èŒ—è·è°·', 'æ–°å¤§å¡š', 'æ± è¢‹'],
            '4å·ç·šä¸¸ãƒå†…ç·šåˆ†å²ç·š': ['ä¸­é‡å‚ä¸Š', 'ä¸­é‡æ–°æ©‹', 'ä¸­é‡å¯Œå£«è¦‹ç”º', 'æ–¹å—ç”º'],
            '5å·ç·šæ±è¥¿ç·š': ['ä¸­é‡', 'è½åˆ', 'é«˜ç”°é¦¬å ´', 'æ—©ç¨²ç”°', 'ç¥æ¥½å‚', 'é£¯ç”°æ©‹', 'ä¹æ®µä¸‹', 'ç«¹æ©‹', 'å¤§æ‰‹ç”º', 'æ—¥æœ¬æ©‹', 'èŒ…å ´ç”º', 'é–€å‰ä»²ç”º', 'æœ¨å ´', 'æ±é™½ç”º', 'å—ç ‚ç”º', 'è¥¿è‘›è¥¿', 'è‘›è¥¿', 'æµ¦å®‰', 'å—è¡Œå¾³', 'è¡Œå¾³', 'å¦™å…¸', 'åŸæœ¨ä¸­å±±', 'è¥¿èˆ¹æ©‹'],
            '7å·ç·šå—åŒ—ç·š': ['ç›®é»’', 'ç™½é‡‘å°', 'ç™½é‡‘é«˜è¼ª', 'éº»å¸ƒåç•ª', 'å…­æœ¬æœ¨ä¸€ä¸ç›®', 'æºœæ± å±±ç‹', 'æ°¸ç”°ç”º', 'å››ãƒ„è°·', 'å¸‚ã‚±è°·', 'é£¯ç”°æ©‹', 'å¾Œæ¥½åœ’', 'æ±å¤§å‰', 'æœ¬é§’è¾¼', 'é§’è¾¼', 'è¥¿ãƒ¶åŸ',
            'ç‹å­', 'ç‹å­ç¥è°·', 'å¿—èŒ‚', 'èµ¤ç¾½å²©æ·µ'],
            '8å·ç·šæœ‰æ¥½ç”ºç·š': ['å’Œå…‰å¸‚', 'åœ°ä¸‹é‰„æˆå¢—', 'åœ°ä¸‹é‰„èµ¤å¡š', 'å¹³å’Œå°', 'æ°·å·å°', 'å°ç«¹å‘åŸ', 'åƒå·', 'è¦ç”º', 'æ± è¢‹', 'æ±æ± è¢‹', 'è­·å›½å¯º', 'æ±Ÿæˆ¸å·æ©‹', 'é£¯ç”°æ©‹', 'å¸‚ã‚±è°·', 'éº¹ç”º', 'æ°¸ç”°ç”º', 'æ¡œç”°é–€', 'æœ‰æ¥½ç”º', 'éŠ€åº§ä¸€ä¸ç›®', 'æ–°å¯Œç”º', 'æœˆå³¶', 'è±Šæ´²', 'è¾°å·³', 'æ–°æœ¨å ´'],
            '9å·ç·šåƒä»£ç”°ç·š': ['ä»£ã€…æœ¨ä¸ŠåŸ', 'ä»£ã€…æœ¨å…¬åœ’', 'æ˜æ²»ç¥å®®å‰', 'è¡¨å‚é“', 'ä¹ƒæœ¨å‚', 'èµ¤å‚', 'å›½ä¼šè­°äº‹å ‚å‰', 'éœã‚±é–¢', 'æ—¥æ¯”è°·', 'äºŒé‡æ©‹å‰', 'å¤§æ‰‹ç”º', 'æ–°å¾¡èŒ¶ãƒæ°´', 'æ¹¯å³¶', 'æ ¹æ´¥', 'åƒé§„æœ¨', 'è¥¿æ—¥æš®é‡Œ', 'ç”ºå±‹', 'åŒ—åƒä½', 'ç¶¾ç€¬', 'åŒ—ç¶¾ç€¬'],
            '11å·ç·šåŠè”µé–€ç·š': ['æ¸‹è°·', 'è¡¨å‚é“', 'é’å±±ä¸€ä¸ç›®', 'æ°¸ç”°ç”º', 'åŠè”µé–€', 'ä¹æ®µä¸‹', 'ç¥ä¿ç”º', 'å¤§æ‰‹ç”º', 'ä¸‰è¶Šå‰', 'æ°´å¤©å®®å‰', 'æ¸…æ¾„ç™½æ²³', 'ä½å‰', 'éŒ¦ç³¸ç”º', 'æŠ¼ä¸Š'],
            '13å·ç·šå‰¯éƒ½å¿ƒç·š': ['å’Œå…‰å¸‚', 'åœ°ä¸‹é‰„æˆå¢—', 'åœ°ä¸‹é‰„èµ¤å¡š', 'å¹³å’Œå°', 'æ°·å·å°', 'å°ç«¹å‘åŸ', 'åƒå·', 'è¦ç”º', 'æ± è¢‹', 'é›‘å¸ãŒè°·', 'è¥¿æ—©ç¨²ç”°', 'æ±æ–°å®¿', 'æ–°å®¿ä¸‰ä¸ç›®', 'åŒ—å‚é“', 'æ˜æ²»ç¥å®®å‰', 'æ¸‹è°·'],
            '1å·ç·šæµ…è‰ç·š': ['è¥¿é¦¬è¾¼', 'é¦¬è¾¼', 'ä¸­å»¶', 'æˆ¸è¶Š', 'äº”åç”°', 'é«˜è¼ªå°', 'æ³‰å²³å¯º', 'ä¸‰ç”°', 'å¤§é–€', 'æ–°æ©‹', 'æ±éŠ€åº§', 'å®ç”º', 'æ—¥æœ¬æ©‹', 'äººå½¢ç”º', 'æ±æ—¥æœ¬æ©‹', 'æµ…è‰æ©‹', 'è”µå‰', 'æµ…è‰', 'æœ¬æ‰€å¾å¦»æ©‹', 'æŠ¼ä¸Š'],
            '6å·ç·šä¸‰ç”°ç·š': ['ç›®é»’', 'ç™½é‡‘å°', 'ç™½é‡‘é«˜è¼ª', 'ä¸‰ç”°', 'èŠå…¬åœ’', 'å¾¡æˆé–€', 'å†…å¹¸ç”º', 'æ—¥æ¯”è°·', 'å¤§æ‰‹ç”º', 'ç¥ä¿ç”º', 'æ°´é“æ©‹', 'æ˜¥æ—¥', 'ç™½å±±', 'åƒçŸ³', 'å·£é´¨', 'è¥¿å·£é´¨', 'æ–°æ¿æ©‹', 'æ¿æ©‹åŒºå½¹æ‰€å‰', 'æ¿æ©‹æœ¬ç”º', 'æœ¬è“®æ²¼', 'å¿—æ‘å‚ä¸Š', 'å¿—æ‘ä¸‰ä¸ç›®', 'è“®æ ¹', 'è¥¿å°', 'é«˜å³¶å¹³', 'æ–°é«˜å³¶å¹³', 'è¥¿é«˜å³¶å¹³'],
            '10å·ç·šæ–°å®¿ç·š': ['æ–°å®¿', 'æ–°å®¿ä¸‰ä¸ç›®', 'æ›™æ©‹', 'å¸‚ãƒ¶è°·', 'ä¹æ®µä¸‹', 'ç¥ä¿ç”º', 'å°å·ç”º', 'å²©æœ¬ç”º', 'é¦¬å–°æ¨ªå±±', 'æµœç”º', 'æ£®ä¸‹', 'èŠå·', 'ä½å‰', 'è¥¿å¤§å³¶', 'å¤§å³¶', 'æ±å¤§å³¶', 'èˆ¹å €', 'ä¸€ä¹‹æ±Ÿ', 'ç‘æ±Ÿ', 'ç¯ å´', 'æœ¬å…«å¹¡'],
            '12å·ç·šå¤§æ±Ÿæˆ¸ç·š': ['æ–°å®¿è¥¿å£', 'æ±æ–°å®¿', 'è‹¥æ¾æ²³ç”°', 'ç‰›è¾¼æŸ³ç”º', 'ç‰›è¾¼ç¥æ¥½å‚', 'é£¯ç”°æ©‹', 'æ˜¥æ—¥', 'æœ¬éƒ·ä¸‰ä¸ç›®', 'ä¸Šé‡å¾¡å¾’ç”º', 'æ–°å¾¡å¾’ç”º', 'è”µå‰', 'ä¸¡å›½', 'æ£®ä¸‹', 'æ¸…æ¾„ç™½æ²³', 'é–€å‰ä»²ç”º', 'æœˆå³¶', 'å‹ã©ã', 'ç¯‰åœ°å¸‚å ´', 'æ±ç•™', 'å¤§é–€', 'èµ¤ç¾½æ©‹', 'éº»å¸ƒåç•ª', 'å…­æœ¬æœ¨', 'é’å±±ä¸€ä¸ç›®', 'å›½ç«‹ç«¶æŠ€å ´', 'ä»£ã€…æœ¨', 'æ–°å®¿', 'éƒ½åºå‰', 'è¥¿æ–°å®¿äº”ä¸ç›®', 'ä¸­é‡å‚ä¸Š', 'æ±ä¸­é‡', 'ä¸­äº•', 'è½åˆå—é•·å´', 'æ–°æ±Ÿå¤ç”°', 'ç·´é¦¬', 'è±Šå³¶åœ’', 'ç·´é¦¬æ˜¥æ—¥ç”º', 'å…‰ãŒä¸˜']
        };

        // ä¸»è¦é§…ãƒªã‚¹ãƒˆ (2Dãƒ†ã‚­ã‚¹ãƒˆã‚’è¡¨ç¤ºã™ã‚‹é§…)
        const mainStations = [
            'ä¸­ç›®é»’', 'åŒ—åƒä½', // æ—¥æ¯”è°·ç·š
            'æ¸‹è°·', 'æµ…è‰', // éŠ€åº§ç·š
            'è»çªª', 'æ± è¢‹', 'æ–¹å—ç”º', // ä¸¸ãƒå†…ç·š
            'ä¸­é‡', 'è¥¿èˆ¹æ©‹', // æ±è¥¿ç·š
            'ç›®é»’', 'èµ¤ç¾½å²©æ·µ', // å—åŒ—ç·š
            'å’Œå…‰å¸‚', 'æ–°æœ¨å ´', // æœ‰æ¥½ç”ºç·š
            'ä»£ã€…æœ¨ä¸ŠåŸ', 'åŒ—ç¶¾ç€¬', // åƒä»£ç”°ç·š
            'æ¸‹è°·', 'æŠ¼ä¸Š', // åŠè”µé–€ç·š
            'å’Œå…‰å¸‚', 'æ¸‹è°·', // å‰¯éƒ½å¿ƒç·š
            'è¥¿é¦¬è¾¼', 'æŠ¼ä¸Š', // æµ…è‰ç·š
            'ç›®é»’', 'è¥¿é«˜å³¶å¹³', // ä¸‰ç”°ç·š
            'æ–°å®¿', 'æœ¬å…«å¹¡', // æ–°å®¿ç·š
            'å…‰ãŒä¸˜', 'éƒ½åºå‰', // å¤§æ±Ÿæˆ¸ç·š
            'æ±äº¬', 'å¤§æ‰‹ç”º', 'éŠ€åº§', 'éœã‚±é–¢', 'æ°¸ç”°ç”º', 'é£¯ç”°æ©‹', 'ä¸Šé‡', 'æ—¥æœ¬æ©‹' // ä¸»è¦ä¹—æ›é§…
        ];

        // JSONãƒ‡ãƒ¼ã‚¿ã‚’éåŒæœŸã§èª­ã¿è¾¼ã‚€é–¢æ•°
        async function loadJSON() {
            try {
                const response = await fetch('metro.json');
                if (!response.ok) throw new Error('JSONãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
                stationData = await response.json();
                console.log('JSONèª­ã¿è¾¼ã¿å®Œäº†:', stationData);

                // é§…ã®åº§æ¨™ã‚’çµ±åˆ
                consolidateStations();

                // é§…ã¨ãƒ©ã‚¤ãƒ³ã®ä½œæˆ
                createStations();
                createLines();
            } catch (error) {
                console.error('ã‚¨ãƒ©ãƒ¼:', error);
                document.getElementById('station-info').innerHTML = 'ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼';
            }
        }

        // è¤‡æ•°è·¯ç·šãŒä¹—ã‚Šå…¥ã‚Œã‚‹é§…ã®åº§æ¨™ã‚’çµ±åˆã™ã‚‹é–¢æ•°
        function consolidateStations() {
            const stationMap = {};

            // åŒä¸€é§…ã®ã‚¨ãƒ³ãƒˆãƒªã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
            stationData.forEach(station => {
                const name = station.station;
                if (!stationMap[name]) {
                    stationMap[name] = {
                        coordinates: [],
                        lines: []
                    };
                }
                stationMap[name].coordinates.push(station.coordinates);
                stationMap[name].lines.push(...station.lines);
            });

            // å¹³å‡åº§æ¨™ã‚’è¨ˆç®—ã—ã€çµ±åˆã•ã‚ŒãŸé§…ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
            consolidatedStations = Object.keys(stationMap).map(name => {
                const coords = stationMap[name].coordinates;
                const avgLon = coords.reduce((sum, c) => sum + c[0], 0) / coords.length;
                const avgLat = coords.reduce((sum, c) => sum + c[1], 0) / coords.length;
                return {
                    station: name,
                    coordinates: [avgLon, avgLat],
                    lines: stationMap[name].lines
                };
            });

            console.log('çµ±åˆã•ã‚ŒãŸé§…ãƒ‡ãƒ¼ã‚¿:', consolidatedStations);
        }

        // Three.jsã‚·ãƒ¼ãƒ³ã®åˆæœŸåŒ–
        function init() {
            // ã‚·ãƒ¼ãƒ³ã®ä½œæˆ
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011);

            // ã‚«ãƒ¡ãƒ©ã®ä½œæˆ
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(40, 200, -20); // èª¿æ•´ã—ãŸåˆæœŸè¦–ç‚¹

            // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ä½œæˆ
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // OrbitControlsã®è¨­å®š
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(-39, 8, -26); // ãƒ¢ãƒ‡ãƒ«ä¸­å¿ƒã‚’æ³¨è¦–
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 200;

            // ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°
            setupLights();

            // JSONèª­ã¿è¾¼ã¿
            loadJSON();

            // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
            renderer.domElement.addEventListener('pointerup', onStationClick);

            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹
            animate();
        } Â  Â 

        // ã‚·ãƒ¼ãƒ³ã«ãƒ©ã‚¤ãƒˆã‚’è¨­å®šã™ã‚‹é–¢æ•°
        function setupLights() {
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0x4ECDC4, 0.5, 100);
            pointLight.position.set(0, -20, 0);
            scene.add(pointLight);
        }

        // ç·¯åº¦çµŒåº¦ã‚’Three.jsã®XYåº§æ¨™ã«å¤‰æ›ã™ã‚‹é–¢æ•°
        function latLonToXY(lon, lat) {
            const centerLon = 139.7;
            const centerLat = 35.68;
            const scale = 1000;
            const x = (lon - centerLon) * scale; // æ±ãŒå³
            const z = (lat - centerLat) * scale; // åŒ—ãŒä¸Š
            return { x, z };
        }

        // Three.jsã®é§…ãƒ¡ãƒƒã‚·ãƒ¥ã¨2Dãƒ©ãƒ™ãƒ«ã‚’ä½œæˆã™ã‚‹é–¢æ•°
        function createStations() {
            const stationGeometry = new THREE.SphereGeometry(0.8, 16, 16);
            const stationMap = {};
            // å¢ƒç•Œãƒœãƒƒã‚¯ã‚¹è¨ˆç®—ç”¨
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity, minZ = Infinity, maxZ = -Infinity;

            // 1. ä¸­å¿ƒè¨ˆç®—ã®ãŸã‚ã«å…¨åº§æ¨™ã‚’ã‚¹ã‚­ãƒ£ãƒ³
            stationData.forEach(station => {
                const pos = latLonToXY(station.coordinates[0], station.coordinates[1]);
                station.lines.forEach(line => {
                    const depth = line.depth !== null ? line.depth * 1.5 : 0; // æ·±ã•ã®å€ç‡ã‚’1.5ã«è¨­å®š
                    minX = Math.min(minX, pos.x);
                    maxX = Math.max(maxX, pos.x);
                    minY = Math.min(minY, depth);
                    maxY = Math.max(maxY, depth);
                    minZ = Math.min(minZ, pos.z);
                    maxZ = Math.max(maxZ, pos.z);
                });
            });

            // ä¸­å¿ƒåº§æ¨™
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const centerZ = (minZ + maxZ) / 2;

            const labelsContainer = document.getElementById('station-labels-container');

            // 2. å„è·¯ç·šã”ã¨ã«é§…ã‚’ä½œæˆ
            consolidatedStations.forEach(station => { // çµ±åˆã•ã‚ŒãŸé§…ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨
                const pos = latLonToXY(station.coordinates[0], station.coordinates[1]);
                const numLines = station.lines.length;

                // è¤‡æ•°è·¯ç·šã®å ´åˆã€é§…ã®çƒä½“ã‚’å°‘ã—ã‚ªãƒ•ã‚»ãƒƒãƒˆã—ã¦æç”»
                station.lines.forEach((line, index) => {
                    const depth = line.depth !== null ? line.depth * 1.5 : 0; // æ·±ã•ã®å€ç‡ã‚’1.5ã«è¨­å®š
                    const color = lineColors[line.name] || 0xffffff;

                    const material = new THREE.MeshPhongMaterial({
                        color: color,
                        emissive: new THREE.Color(color).multiplyScalar(0.2)
                    });

                    const stationMesh = new THREE.Mesh(stationGeometry, material);
                    
                    let offsetX = 0, offsetZ = 0;
                    if (numLines > 1) {
                        const angle = (index / numLines) * Math.PI * 2; // å††å½¢é…ç½®
                        const radius = 1.2; // ã‚ªãƒ•ã‚»ãƒƒãƒˆåŠå¾„
                        offsetX = Math.cos(angle) * radius;
                        offsetZ = Math.sin(angle) * radius;
                    }
                    // åº§æ¨™èª¿æ•´: ãƒ¢ãƒ‡ãƒ«ã®ä¸­å¿ƒã‚’åŸç‚¹ã«è¿‘ã¥ã‘ã‚‹
                    stationMesh.position.set(pos.x - centerX + offsetX, depth - centerY, -pos.z - centerZ + offsetZ);
                    stationMesh.castShadow = true;
                    stationMesh.receiveShadow = true;

                    stationMesh.userData = {
                        name: station.station,
                        lines: station.lines,
                        coordinates: station.coordinates
                    };

                    scene.add(stationMesh);
                    stations.push(stationMesh);
                });

                // ä¸»è¦é§…ã®å ´åˆã€2D HTMLãƒ†ã‚­ã‚¹ãƒˆãƒ©ãƒ™ãƒ«ã‚’è¿½åŠ 
                if (mainStations.includes(station.station)) {
                    const labelDiv = document.createElement('div');
                    labelDiv.className = 'station-label';
                    labelDiv.textContent = station.station;
                    labelsContainer.appendChild(labelDiv);

                    // ãƒ©ãƒ™ãƒ«ã®Three.jsãƒ¡ãƒƒã‚·ãƒ¥ã¨HTMLè¦ç´ ã‚’é–¢é€£ä»˜ã‘ã¦ä¿å­˜
                    stationLabels.push({
                        mesh: stations.find(m => m.userData.name === station.station), // æœ€åˆã®ãƒ¡ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨
                        element: labelDiv
                    });
                }
            });

            // ä¸­å¿ƒåº§æ¨™ã‚’ãƒ­ã‚° (ãƒ‡ãƒãƒƒã‚°ç”¨)
            console.log('Model Center:', { x: centerX.toFixed(2), y: centerY.toFixed(2), z: centerZ.toFixed(2) });
        }

        // Three.jsã®è·¯ç·šãƒãƒ¥ãƒ¼ãƒ–ã‚’ä½œæˆã™ã‚‹é–¢æ•°
        function createLines() {
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity, minZ = Infinity, maxZ = -Infinity;

            // å¢ƒç•Œãƒœãƒƒã‚¯ã‚¹è¨ˆç®—ï¼ˆçµ±åˆã•ã‚ŒãŸåº§æ¨™ã‚’ä½¿ç”¨ï¼‰
            consolidatedStations.forEach(station => {
                const pos = latLonToXY(station.coordinates[0], station.coordinates[1]);
                station.lines.forEach(line => {
                    const depth = line.depth !== null ? line.depth * 1.5 : 0; // æ·±ã•ã®å€ç‡ã‚’1.5ã«è¨­å®š
                    minX = Math.min(minX, pos.x);
                    maxX = Math.max(maxX, pos.x);
                    minY = Math.min(minY, depth);
                    maxY = Math.max(maxY, depth);
                    minZ = Math.min(minZ, pos.z);
                    maxZ = Math.max(maxZ, pos.z);
                });
            });

            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const centerZ = (minZ + maxZ) / 2;

            Object.keys(lineOrders).forEach(lineName => {
                const stationNames = lineOrders[lineName];
                const points = [];

                // çµ±åˆã•ã‚ŒãŸåº§æ¨™ã‚’ä½¿ç”¨ã—ã¦ãƒã‚¤ãƒ³ãƒˆã‚’åé›†
                stationNames.forEach(stationName => {
                    const station = consolidatedStations.find(s => s.station === stationName);
                    if (station) {
                        const line = station.lines.find(l => l.name === lineName);
                        if (line) {
                            const pos = latLonToXY(station.coordinates[0], station.coordinates[1]);
                            const depth = line.depth !== null ? line.depth * 1.5 : 0;
                            // åº§æ¨™èª¿æ•´: ãƒ¢ãƒ‡ãƒ«ã®ä¸­å¿ƒã‚’åŸç‚¹ã«è¿‘ã¥ã‘ã‚‹
                            points.push(new THREE.Vector3(pos.x - centerX, depth - centerY, -pos.z - centerZ));
                        }
                    }
                });

                if (points.length < 2) return; // å°‘ãªãã¨ã‚‚2ç‚¹å¿…è¦

                // å„é§…ãƒšã‚¢é–“ã«ç›´ç·šãƒãƒ¥ãƒ¼ãƒ–ï¼ˆã‚·ãƒªãƒ³ãƒ€ãƒ¼ï¼‰ã‚’ä½œæˆ
                for (let i = 0; i < points.length - 1; i++) {
                    const start = points[i];
                    const end = points[i + 1];

                    // ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã®é•·ã•ã¨æ–¹å‘ã‚’è¨ˆç®—
                    const direction = new THREE.Vector3().subVectors(end, start);
                    const length = direction.length();
                    const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);

                    // ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã®ã‚¸ã‚ªãƒ¡ãƒˆãƒªã¨ãƒãƒ†ãƒªã‚¢ãƒ«
                    const cylinderGeometry = new THREE.CylinderGeometry(0.5, 0.5, length, 8);
                    const cylinderMaterial = new THREE.MeshPhongMaterial({
                        color: lineColors[lineName] || 0xffffff,
                        emissive: new THREE.Color(lineColors[lineName] || 0xffffff).multiplyScalar(0.2)
                    });

                    const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);

                    // ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã®ä½ç½®ã¨å›è»¢ã‚’è¨­å®š
                    cylinder.position.copy(midpoint);
                    cylinder.quaternion.setFromUnitVectors(
                        new THREE.Vector3(0, 1, 0), // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚·ãƒªãƒ³ãƒ€ãƒ¼è»¸ï¼ˆYè»¸ï¼‰
                        direction.clone().normalize() // é–‹å§‹ç‚¹ã‹ã‚‰çµ‚ç‚¹ã¸ã®æ–¹å‘
                    );

                    cylinder.castShadow = true;
                    cylinder.receiveShadow = true;
                    cylinder.userData = { lineName };

                    scene.add(cylinder);
                    lines.push(cylinder);
                }
            });
        }

        // é§…ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã®ãƒãƒ³ãƒ‰ãƒ©
        function onStationClick(event) {
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(stations);

            if (intersects.length > 0) {
                const station = intersects[0].object.userData;
                const linesInfo = station.lines.map(line => 
                    `${line.name.replace(/^\d+å·ç·š/, '')}: ${line.depth !== null ? line.depth + 'm' : 'ä¸æ˜'}`
                ).join('<br>');
                document.getElementById('station-info').innerHTML = `
                    <strong>${station.name}</strong><br>
                    è·¯ç·šã¨æ·±åº¦:<br>${linesInfo}<br>
                    åº§æ¨™: ${station.coordinates[1].toFixed(4)}, ${station.coordinates[0].toFixed(4)}
                `;
            }
        }

        // ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã‚’ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ã«å¤‰æ›ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
        const tempV = new THREE.Vector3(); // æ¯å›æ–°ã—ã„Vector3ã‚’ä½œæˆã™ã‚‹ã®ã‚’é¿ã‘ã‚‹ãŸã‚
        function worldToScreen(vector3, camera, renderer) {
            tempV.copy(vector3);
            tempV.project(camera);

            const x = (tempV.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
            const y = (-tempV.y * 0.5 + 0.5) * renderer.domElement.clientHeight;

            return { x, y };
        }

        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
        function animate() {
            requestAnimationFrame(animate);

            if (isAnimating) {
                const time = Date.now() * 0.0005;
                camera.position.x = Math.cos(time) * 80;
                camera.position.z = Math.sin(time) * 80;
                camera.lookAt(controls.target); // controls.targetã‚’è¦‹ã‚‹ã‚ˆã†ã«å¤‰æ›´
            }

            // é§…ã®ç‚¹æ»…ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
            stations.forEach((station, index) => {
                const time = Date.now() * 0.003 + index * 0.1;
                const intensity = 0.2 + Math.sin(time) * 0.1;
                station.material.emissiveIntensity = intensity;
            });

            // 2Dé§…åãƒ©ãƒ™ãƒ«ã®ä½ç½®ã‚’æ›´æ–°
            stationLabels.forEach(label => {
                // é§…ã®ãƒ¡ãƒƒã‚·ãƒ¥ã®ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã‚’å–å¾—
                label.mesh.updateWorldMatrix(true, false);
                const screenPosition = worldToScreen(label.mesh.position, camera, renderer);
                
                label.element.style.left = `${screenPosition.x}px`;
                label.element.style.top = `${screenPosition.y}px`;

                // ã‚«ãƒ¡ãƒ©ã«å¯¾ã™ã‚‹å‘ãã‚’è€ƒæ…®ã—ã¦ã€ãƒ©ãƒ™ãƒ«ã®è¡¨ç¤º/éè¡¨ç¤ºã‚’èª¿æ•´ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
                // é§…ãŒã‚«ãƒ¡ãƒ©ã®èƒŒå¾Œã«ã‚ã‚‹å ´åˆã¯éè¡¨ç¤ºã«ã™ã‚‹
                tempV.copy(label.mesh.position);
                tempV.project(camera);
                label.element.style.display = (tempV.z > 1 || tempV.z < -1) ? 'none' : (label.element.dataset.visible === 'true' ? 'block' : 'none');
            });

            controls.update();
            renderer.render(scene, camera);
        }

        // ãƒ“ãƒ¥ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹é–¢æ•° (ç¾åœ¨æœªä½¿ç”¨)
        function resetView() {
            camera.position.set(40, 200, -20);
            controls.target.set(0, 0, 0);
            controls.update();
        }

        // ã‚«ãƒ¡ãƒ©ã®è‡ªå‹•å›è»¢ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹é–¢æ•°
        function toggleAnimation() {
            isAnimating = !isAnimating;
        }

        // ä¸»è¦é§…ã®ãƒ†ã‚­ã‚¹ãƒˆãƒ©ãƒ™ãƒ«è¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹é–¢æ•°
        function toggleStationLabels() {
            const labelsContainer = document.getElementById('station-labels-container');
            const isVisible = labelsContainer.style.display !== 'none';
            labelsContainer.style.display = isVisible ? 'none' : 'block';

            // å„ãƒ©ãƒ™ãƒ«ã®è¡¨ç¤ºçŠ¶æ…‹ã‚’ãƒ‡ãƒ¼ã‚¿å±æ€§ã«ä¿å­˜
            stationLabels.forEach(label => {
                label.element.dataset.visible = (!isVisible).toString();
            });
        }

        // è·¯ç·šã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã™ã‚‹é–¢æ•°
        function focusLine(selectedLine) {
            if (!selectedLine) {
                // å…¨ã¦ã®é§…ã¨ãƒ©ã‚¤ãƒ³ã‚’å…ƒã®çŠ¶æ…‹ã«æˆ»ã™
                stations.forEach(station => {
                    station.material.opacity = 1.0;
                    station.material.transparent = false;
                });
                lines.forEach(line => {
                    line.material.opacity = 1.0;
                    line.material.transparent = false;
                });
                return;
            }

            // å…¨ã¦ã®é§…ã¨ãƒ©ã‚¤ãƒ³ã‚’åŠé€æ˜ã«ã™ã‚‹
            stations.forEach(station => {
                station.material.opacity = 0.3;
                station.material.transparent = true;
            });
            lines.forEach(line => {
                line.material.opacity = 0.3;
                line.material.transparent = true;
            });

            // é¸æŠã•ã‚ŒãŸè·¯ç·šã®é§…ã¨ãƒ©ã‚¤ãƒ³ã‚’ä¸é€æ˜ã«ã™ã‚‹
            stations.forEach(station => {
                if (station.userData.lines.some(line => line.name.includes(selectedLine))) {
                    station.material.opacity = 1.0;
                    station.material.transparent = false;
                }
            });
            lines.forEach(line => {
                if (line.userData.lineName.includes(selectedLine)) {
                    line.material.opacity = 1.0;
                    line.material.transparent = false;
                }
            });

            // ãƒ†ã‚­ã‚¹ãƒˆãƒ©ãƒ™ãƒ«ã¯å½±éŸ¿ã‚’å—ã‘ãªã„ã‚ˆã†ã«ã™ã‚‹
            // å¿…è¦ã§ã‚ã‚Œã°ã€ã“ã“ã§ç‰¹å®šã®è·¯ç·šã®ãƒ©ãƒ™ãƒ«ã®ã¿è¡¨ç¤ºã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã‚’è¿½åŠ ã§ãã¾ã™
        }

        // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ãƒªã‚µã‚¤ã‚ºã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // åˆæœŸåŒ–å‡¦ç†ã‚’é–‹å§‹
        init();

        // UIã‚’é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        const closeUiButton = document.getElementById('close-ui');
        if (closeUiButton) {
            closeUiButton.addEventListener('click', () => {
                const uiElement = document.getElementById('ui');
                if (uiElement) {
                    uiElement.style.display = 'none';
                }
            });
        }
    </script>
</body>
</html>
